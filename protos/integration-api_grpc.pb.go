// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.20.3
// source: integration-api.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BedrockService_Embedding_FullMethodName        = "/integration_api.BedrockService/Embedding"
	BedrockService_Chat_FullMethodName             = "/integration_api.BedrockService/Chat"
	BedrockService_VerifyCredential_FullMethodName = "/integration_api.BedrockService/VerifyCredential"
)

// BedrockServiceClient is the client API for BedrockService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BedrockServiceClient interface {
	Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type bedrockServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBedrockServiceClient(cc grpc.ClientConnInterface) BedrockServiceClient {
	return &bedrockServiceClient{cc}
}

func (c *bedrockServiceClient) Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, BedrockService_Embedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bedrockServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, BedrockService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bedrockServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, BedrockService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BedrockServiceServer is the server API for BedrockService service.
// All implementations should embed UnimplementedBedrockServiceServer
// for forward compatibility.
type BedrockServiceServer interface {
	Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error)
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedBedrockServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBedrockServiceServer struct{}

func (UnimplementedBedrockServiceServer) Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Embedding not implemented")
}
func (UnimplementedBedrockServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedBedrockServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedBedrockServiceServer) testEmbeddedByValue() {}

// UnsafeBedrockServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BedrockServiceServer will
// result in compilation errors.
type UnsafeBedrockServiceServer interface {
	mustEmbedUnimplementedBedrockServiceServer()
}

func RegisterBedrockServiceServer(s grpc.ServiceRegistrar, srv BedrockServiceServer) {
	// If the following call pancis, it indicates UnimplementedBedrockServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BedrockService_ServiceDesc, srv)
}

func _BedrockService_Embedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BedrockServiceServer).Embedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BedrockService_Embedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BedrockServiceServer).Embedding(ctx, req.(*EmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BedrockService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BedrockServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BedrockService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BedrockServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BedrockService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BedrockServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BedrockService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BedrockServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BedrockService_ServiceDesc is the grpc.ServiceDesc for BedrockService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BedrockService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.BedrockService",
	HandlerType: (*BedrockServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Embedding",
			Handler:    _BedrockService_Embedding_Handler,
		},
		{
			MethodName: "Chat",
			Handler:    _BedrockService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _BedrockService_VerifyCredential_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration-api.proto",
}

const (
	OpenAiService_Embedding_FullMethodName        = "/integration_api.OpenAiService/Embedding"
	OpenAiService_Chat_FullMethodName             = "/integration_api.OpenAiService/Chat"
	OpenAiService_StreamChat_FullMethodName       = "/integration_api.OpenAiService/StreamChat"
	OpenAiService_VerifyCredential_FullMethodName = "/integration_api.OpenAiService/VerifyCredential"
	OpenAiService_GetModeration_FullMethodName    = "/integration_api.OpenAiService/GetModeration"
)

// OpenAiServiceClient is the client API for OpenAiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OpenAiServiceClient interface {
	Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
	GetModeration(ctx context.Context, in *GetModerationRequest, opts ...grpc.CallOption) (*GetModerationResponse, error)
}

type openAiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOpenAiServiceClient(cc grpc.ClientConnInterface) OpenAiServiceClient {
	return &openAiServiceClient{cc}
}

func (c *openAiServiceClient) Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, OpenAiService_Embedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAiServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, OpenAiService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAiServiceClient) StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &OpenAiService_ServiceDesc.Streams[0], OpenAiService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OpenAiService_StreamChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *openAiServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, OpenAiService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAiServiceClient) GetModeration(ctx context.Context, in *GetModerationRequest, opts ...grpc.CallOption) (*GetModerationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModerationResponse)
	err := c.cc.Invoke(ctx, OpenAiService_GetModeration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenAiServiceServer is the server API for OpenAiService service.
// All implementations should embed UnimplementedOpenAiServiceServer
// for forward compatibility.
type OpenAiServiceServer interface {
	Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error)
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
	GetModeration(context.Context, *GetModerationRequest) (*GetModerationResponse, error)
}

// UnimplementedOpenAiServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOpenAiServiceServer struct{}

func (UnimplementedOpenAiServiceServer) Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Embedding not implemented")
}
func (UnimplementedOpenAiServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedOpenAiServiceServer) StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedOpenAiServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedOpenAiServiceServer) GetModeration(context.Context, *GetModerationRequest) (*GetModerationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModeration not implemented")
}
func (UnimplementedOpenAiServiceServer) testEmbeddedByValue() {}

// UnsafeOpenAiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OpenAiServiceServer will
// result in compilation errors.
type UnsafeOpenAiServiceServer interface {
	mustEmbedUnimplementedOpenAiServiceServer()
}

func RegisterOpenAiServiceServer(s grpc.ServiceRegistrar, srv OpenAiServiceServer) {
	// If the following call pancis, it indicates UnimplementedOpenAiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OpenAiService_ServiceDesc, srv)
}

func _OpenAiService_Embedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAiServiceServer).Embedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAiService_Embedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAiServiceServer).Embedding(ctx, req.(*EmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAiService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAiServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAiService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAiServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAiService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OpenAiServiceServer).StreamChat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OpenAiService_StreamChatServer = grpc.ServerStreamingServer[ChatResponse]

func _OpenAiService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAiServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAiService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAiServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAiService_GetModeration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModerationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAiServiceServer).GetModeration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAiService_GetModeration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAiServiceServer).GetModeration(ctx, req.(*GetModerationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OpenAiService_ServiceDesc is the grpc.ServiceDesc for OpenAiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OpenAiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.OpenAiService",
	HandlerType: (*OpenAiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Embedding",
			Handler:    _OpenAiService_Embedding_Handler,
		},
		{
			MethodName: "Chat",
			Handler:    _OpenAiService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _OpenAiService_VerifyCredential_Handler,
		},
		{
			MethodName: "GetModeration",
			Handler:    _OpenAiService_GetModeration_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _OpenAiService_StreamChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integration-api.proto",
}

const (
	AzureService_Embedding_FullMethodName        = "/integration_api.AzureService/Embedding"
	AzureService_Chat_FullMethodName             = "/integration_api.AzureService/Chat"
	AzureService_StreamChat_FullMethodName       = "/integration_api.AzureService/StreamChat"
	AzureService_VerifyCredential_FullMethodName = "/integration_api.AzureService/VerifyCredential"
	AzureService_GetModeration_FullMethodName    = "/integration_api.AzureService/GetModeration"
)

// AzureServiceClient is the client API for AzureService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AzureServiceClient interface {
	Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
	GetModeration(ctx context.Context, in *GetModerationRequest, opts ...grpc.CallOption) (*GetModerationResponse, error)
}

type azureServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAzureServiceClient(cc grpc.ClientConnInterface) AzureServiceClient {
	return &azureServiceClient{cc}
}

func (c *azureServiceClient) Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, AzureService_Embedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *azureServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, AzureService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *azureServiceClient) StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AzureService_ServiceDesc.Streams[0], AzureService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AzureService_StreamChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *azureServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, AzureService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *azureServiceClient) GetModeration(ctx context.Context, in *GetModerationRequest, opts ...grpc.CallOption) (*GetModerationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModerationResponse)
	err := c.cc.Invoke(ctx, AzureService_GetModeration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AzureServiceServer is the server API for AzureService service.
// All implementations should embed UnimplementedAzureServiceServer
// for forward compatibility.
type AzureServiceServer interface {
	Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error)
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
	GetModeration(context.Context, *GetModerationRequest) (*GetModerationResponse, error)
}

// UnimplementedAzureServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAzureServiceServer struct{}

func (UnimplementedAzureServiceServer) Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Embedding not implemented")
}
func (UnimplementedAzureServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedAzureServiceServer) StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedAzureServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedAzureServiceServer) GetModeration(context.Context, *GetModerationRequest) (*GetModerationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModeration not implemented")
}
func (UnimplementedAzureServiceServer) testEmbeddedByValue() {}

// UnsafeAzureServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AzureServiceServer will
// result in compilation errors.
type UnsafeAzureServiceServer interface {
	mustEmbedUnimplementedAzureServiceServer()
}

func RegisterAzureServiceServer(s grpc.ServiceRegistrar, srv AzureServiceServer) {
	// If the following call pancis, it indicates UnimplementedAzureServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AzureService_ServiceDesc, srv)
}

func _AzureService_Embedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AzureServiceServer).Embedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AzureService_Embedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AzureServiceServer).Embedding(ctx, req.(*EmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AzureService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AzureServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AzureService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AzureServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AzureService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AzureServiceServer).StreamChat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AzureService_StreamChatServer = grpc.ServerStreamingServer[ChatResponse]

func _AzureService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AzureServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AzureService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AzureServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AzureService_GetModeration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModerationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AzureServiceServer).GetModeration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AzureService_GetModeration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AzureServiceServer).GetModeration(ctx, req.(*GetModerationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AzureService_ServiceDesc is the grpc.ServiceDesc for AzureService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AzureService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.AzureService",
	HandlerType: (*AzureServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Embedding",
			Handler:    _AzureService_Embedding_Handler,
		},
		{
			MethodName: "Chat",
			Handler:    _AzureService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _AzureService_VerifyCredential_Handler,
		},
		{
			MethodName: "GetModeration",
			Handler:    _AzureService_GetModeration_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _AzureService_StreamChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integration-api.proto",
}

const (
	GoogleService_Embedding_FullMethodName        = "/integration_api.GoogleService/Embedding"
	GoogleService_Chat_FullMethodName             = "/integration_api.GoogleService/Chat"
	GoogleService_StreamChat_FullMethodName       = "/integration_api.GoogleService/StreamChat"
	GoogleService_VerifyCredential_FullMethodName = "/integration_api.GoogleService/VerifyCredential"
)

// GoogleServiceClient is the client API for GoogleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GoogleServiceClient interface {
	Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type googleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGoogleServiceClient(cc grpc.ClientConnInterface) GoogleServiceClient {
	return &googleServiceClient{cc}
}

func (c *googleServiceClient) Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, GoogleService_Embedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *googleServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, GoogleService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *googleServiceClient) StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GoogleService_ServiceDesc.Streams[0], GoogleService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GoogleService_StreamChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *googleServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, GoogleService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GoogleServiceServer is the server API for GoogleService service.
// All implementations should embed UnimplementedGoogleServiceServer
// for forward compatibility.
type GoogleServiceServer interface {
	Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error)
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedGoogleServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGoogleServiceServer struct{}

func (UnimplementedGoogleServiceServer) Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Embedding not implemented")
}
func (UnimplementedGoogleServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedGoogleServiceServer) StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedGoogleServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedGoogleServiceServer) testEmbeddedByValue() {}

// UnsafeGoogleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GoogleServiceServer will
// result in compilation errors.
type UnsafeGoogleServiceServer interface {
	mustEmbedUnimplementedGoogleServiceServer()
}

func RegisterGoogleServiceServer(s grpc.ServiceRegistrar, srv GoogleServiceServer) {
	// If the following call pancis, it indicates UnimplementedGoogleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GoogleService_ServiceDesc, srv)
}

func _GoogleService_Embedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoogleServiceServer).Embedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoogleService_Embedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoogleServiceServer).Embedding(ctx, req.(*EmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoogleService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoogleServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoogleService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoogleServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoogleService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GoogleServiceServer).StreamChat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GoogleService_StreamChatServer = grpc.ServerStreamingServer[ChatResponse]

func _GoogleService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoogleServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoogleService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoogleServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GoogleService_ServiceDesc is the grpc.ServiceDesc for GoogleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GoogleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.GoogleService",
	HandlerType: (*GoogleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Embedding",
			Handler:    _GoogleService_Embedding_Handler,
		},
		{
			MethodName: "Chat",
			Handler:    _GoogleService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _GoogleService_VerifyCredential_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _GoogleService_StreamChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integration-api.proto",
}

const (
	ReplicateService_Chat_FullMethodName             = "/integration_api.ReplicateService/Chat"
	ReplicateService_StreamChat_FullMethodName       = "/integration_api.ReplicateService/StreamChat"
	ReplicateService_VerifyCredential_FullMethodName = "/integration_api.ReplicateService/VerifyCredential"
)

// ReplicateServiceClient is the client API for ReplicateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReplicateServiceClient interface {
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type replicateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicateServiceClient(cc grpc.ClientConnInterface) ReplicateServiceClient {
	return &replicateServiceClient{cc}
}

func (c *replicateServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, ReplicateService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicateServiceClient) StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReplicateService_ServiceDesc.Streams[0], ReplicateService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplicateService_StreamChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *replicateServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, ReplicateService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicateServiceServer is the server API for ReplicateService service.
// All implementations should embed UnimplementedReplicateServiceServer
// for forward compatibility.
type ReplicateServiceServer interface {
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedReplicateServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReplicateServiceServer struct{}

func (UnimplementedReplicateServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedReplicateServiceServer) StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedReplicateServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedReplicateServiceServer) testEmbeddedByValue() {}

// UnsafeReplicateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicateServiceServer will
// result in compilation errors.
type UnsafeReplicateServiceServer interface {
	mustEmbedUnimplementedReplicateServiceServer()
}

func RegisterReplicateServiceServer(s grpc.ServiceRegistrar, srv ReplicateServiceServer) {
	// If the following call pancis, it indicates UnimplementedReplicateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReplicateService_ServiceDesc, srv)
}

func _ReplicateService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicateServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicateService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicateServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicateService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplicateServiceServer).StreamChat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplicateService_StreamChatServer = grpc.ServerStreamingServer[ChatResponse]

func _ReplicateService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicateServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicateService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicateServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReplicateService_ServiceDesc is the grpc.ServiceDesc for ReplicateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplicateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.ReplicateService",
	HandlerType: (*ReplicateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _ReplicateService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _ReplicateService_VerifyCredential_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _ReplicateService_StreamChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integration-api.proto",
}

const (
	AnthropicService_Chat_FullMethodName             = "/integration_api.AnthropicService/Chat"
	AnthropicService_StreamChat_FullMethodName       = "/integration_api.AnthropicService/StreamChat"
	AnthropicService_VerifyCredential_FullMethodName = "/integration_api.AnthropicService/VerifyCredential"
)

// AnthropicServiceClient is the client API for AnthropicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnthropicServiceClient interface {
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type anthropicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAnthropicServiceClient(cc grpc.ClientConnInterface) AnthropicServiceClient {
	return &anthropicServiceClient{cc}
}

func (c *anthropicServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, AnthropicService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anthropicServiceClient) StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AnthropicService_ServiceDesc.Streams[0], AnthropicService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AnthropicService_StreamChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *anthropicServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, AnthropicService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnthropicServiceServer is the server API for AnthropicService service.
// All implementations should embed UnimplementedAnthropicServiceServer
// for forward compatibility.
type AnthropicServiceServer interface {
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedAnthropicServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAnthropicServiceServer struct{}

func (UnimplementedAnthropicServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedAnthropicServiceServer) StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedAnthropicServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedAnthropicServiceServer) testEmbeddedByValue() {}

// UnsafeAnthropicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnthropicServiceServer will
// result in compilation errors.
type UnsafeAnthropicServiceServer interface {
	mustEmbedUnimplementedAnthropicServiceServer()
}

func RegisterAnthropicServiceServer(s grpc.ServiceRegistrar, srv AnthropicServiceServer) {
	// If the following call pancis, it indicates UnimplementedAnthropicServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AnthropicService_ServiceDesc, srv)
}

func _AnthropicService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnthropicServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnthropicService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnthropicServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnthropicService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AnthropicServiceServer).StreamChat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AnthropicService_StreamChatServer = grpc.ServerStreamingServer[ChatResponse]

func _AnthropicService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnthropicServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnthropicService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnthropicServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AnthropicService_ServiceDesc is the grpc.ServiceDesc for AnthropicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AnthropicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.AnthropicService",
	HandlerType: (*AnthropicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _AnthropicService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _AnthropicService_VerifyCredential_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _AnthropicService_StreamChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integration-api.proto",
}

const (
	CohereService_Embedding_FullMethodName        = "/integration_api.CohereService/Embedding"
	CohereService_Reranking_FullMethodName        = "/integration_api.CohereService/Reranking"
	CohereService_Chat_FullMethodName             = "/integration_api.CohereService/Chat"
	CohereService_StreamChat_FullMethodName       = "/integration_api.CohereService/StreamChat"
	CohereService_VerifyCredential_FullMethodName = "/integration_api.CohereService/VerifyCredential"
)

// CohereServiceClient is the client API for CohereService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CohereServiceClient interface {
	Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	Reranking(ctx context.Context, in *RerankingRequest, opts ...grpc.CallOption) (*RerankingResponse, error)
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type cohereServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCohereServiceClient(cc grpc.ClientConnInterface) CohereServiceClient {
	return &cohereServiceClient{cc}
}

func (c *cohereServiceClient) Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, CohereService_Embedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cohereServiceClient) Reranking(ctx context.Context, in *RerankingRequest, opts ...grpc.CallOption) (*RerankingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RerankingResponse)
	err := c.cc.Invoke(ctx, CohereService_Reranking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cohereServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, CohereService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cohereServiceClient) StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CohereService_ServiceDesc.Streams[0], CohereService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CohereService_StreamChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *cohereServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, CohereService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CohereServiceServer is the server API for CohereService service.
// All implementations should embed UnimplementedCohereServiceServer
// for forward compatibility.
type CohereServiceServer interface {
	Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error)
	Reranking(context.Context, *RerankingRequest) (*RerankingResponse, error)
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedCohereServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCohereServiceServer struct{}

func (UnimplementedCohereServiceServer) Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Embedding not implemented")
}
func (UnimplementedCohereServiceServer) Reranking(context.Context, *RerankingRequest) (*RerankingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reranking not implemented")
}
func (UnimplementedCohereServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedCohereServiceServer) StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedCohereServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedCohereServiceServer) testEmbeddedByValue() {}

// UnsafeCohereServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CohereServiceServer will
// result in compilation errors.
type UnsafeCohereServiceServer interface {
	mustEmbedUnimplementedCohereServiceServer()
}

func RegisterCohereServiceServer(s grpc.ServiceRegistrar, srv CohereServiceServer) {
	// If the following call pancis, it indicates UnimplementedCohereServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CohereService_ServiceDesc, srv)
}

func _CohereService_Embedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CohereServiceServer).Embedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CohereService_Embedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CohereServiceServer).Embedding(ctx, req.(*EmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CohereService_Reranking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CohereServiceServer).Reranking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CohereService_Reranking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CohereServiceServer).Reranking(ctx, req.(*RerankingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CohereService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CohereServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CohereService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CohereServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CohereService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CohereServiceServer).StreamChat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CohereService_StreamChatServer = grpc.ServerStreamingServer[ChatResponse]

func _CohereService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CohereServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CohereService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CohereServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CohereService_ServiceDesc is the grpc.ServiceDesc for CohereService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CohereService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.CohereService",
	HandlerType: (*CohereServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Embedding",
			Handler:    _CohereService_Embedding_Handler,
		},
		{
			MethodName: "Reranking",
			Handler:    _CohereService_Reranking_Handler,
		},
		{
			MethodName: "Chat",
			Handler:    _CohereService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _CohereService_VerifyCredential_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _CohereService_StreamChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integration-api.proto",
}

const (
	HuggingfaceService_Chat_FullMethodName             = "/integration_api.HuggingfaceService/Chat"
	HuggingfaceService_VerifyCredential_FullMethodName = "/integration_api.HuggingfaceService/VerifyCredential"
)

// HuggingfaceServiceClient is the client API for HuggingfaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HuggingfaceServiceClient interface {
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type huggingfaceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHuggingfaceServiceClient(cc grpc.ClientConnInterface) HuggingfaceServiceClient {
	return &huggingfaceServiceClient{cc}
}

func (c *huggingfaceServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, HuggingfaceService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *huggingfaceServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, HuggingfaceService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HuggingfaceServiceServer is the server API for HuggingfaceService service.
// All implementations should embed UnimplementedHuggingfaceServiceServer
// for forward compatibility.
type HuggingfaceServiceServer interface {
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedHuggingfaceServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHuggingfaceServiceServer struct{}

func (UnimplementedHuggingfaceServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedHuggingfaceServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedHuggingfaceServiceServer) testEmbeddedByValue() {}

// UnsafeHuggingfaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HuggingfaceServiceServer will
// result in compilation errors.
type UnsafeHuggingfaceServiceServer interface {
	mustEmbedUnimplementedHuggingfaceServiceServer()
}

func RegisterHuggingfaceServiceServer(s grpc.ServiceRegistrar, srv HuggingfaceServiceServer) {
	// If the following call pancis, it indicates UnimplementedHuggingfaceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HuggingfaceService_ServiceDesc, srv)
}

func _HuggingfaceService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HuggingfaceServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HuggingfaceService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HuggingfaceServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HuggingfaceService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HuggingfaceServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HuggingfaceService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HuggingfaceServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HuggingfaceService_ServiceDesc is the grpc.ServiceDesc for HuggingfaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HuggingfaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.HuggingfaceService",
	HandlerType: (*HuggingfaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _HuggingfaceService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _HuggingfaceService_VerifyCredential_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration-api.proto",
}

const (
	MistralService_Chat_FullMethodName             = "/integration_api.MistralService/Chat"
	MistralService_StreamChat_FullMethodName       = "/integration_api.MistralService/StreamChat"
	MistralService_VerifyCredential_FullMethodName = "/integration_api.MistralService/VerifyCredential"
)

// MistralServiceClient is the client API for MistralService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MistralServiceClient interface {
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type mistralServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMistralServiceClient(cc grpc.ClientConnInterface) MistralServiceClient {
	return &mistralServiceClient{cc}
}

func (c *mistralServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, MistralService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mistralServiceClient) StreamChat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MistralService_ServiceDesc.Streams[0], MistralService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MistralService_StreamChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *mistralServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, MistralService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MistralServiceServer is the server API for MistralService service.
// All implementations should embed UnimplementedMistralServiceServer
// for forward compatibility.
type MistralServiceServer interface {
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedMistralServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMistralServiceServer struct{}

func (UnimplementedMistralServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedMistralServiceServer) StreamChat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedMistralServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedMistralServiceServer) testEmbeddedByValue() {}

// UnsafeMistralServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MistralServiceServer will
// result in compilation errors.
type UnsafeMistralServiceServer interface {
	mustEmbedUnimplementedMistralServiceServer()
}

func RegisterMistralServiceServer(s grpc.ServiceRegistrar, srv MistralServiceServer) {
	// If the following call pancis, it indicates UnimplementedMistralServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MistralService_ServiceDesc, srv)
}

func _MistralService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MistralServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MistralService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MistralServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MistralService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MistralServiceServer).StreamChat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MistralService_StreamChatServer = grpc.ServerStreamingServer[ChatResponse]

func _MistralService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MistralServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MistralService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MistralServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MistralService_ServiceDesc is the grpc.ServiceDesc for MistralService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MistralService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.MistralService",
	HandlerType: (*MistralServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _MistralService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _MistralService_VerifyCredential_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _MistralService_StreamChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integration-api.proto",
}

const (
	StabilityAiService_VerifyCredential_FullMethodName = "/integration_api.StabilityAiService/VerifyCredential"
)

// StabilityAiServiceClient is the client API for StabilityAiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StabilityAiServiceClient interface {
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type stabilityAiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStabilityAiServiceClient(cc grpc.ClientConnInterface) StabilityAiServiceClient {
	return &stabilityAiServiceClient{cc}
}

func (c *stabilityAiServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, StabilityAiService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StabilityAiServiceServer is the server API for StabilityAiService service.
// All implementations should embed UnimplementedStabilityAiServiceServer
// for forward compatibility.
type StabilityAiServiceServer interface {
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedStabilityAiServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStabilityAiServiceServer struct{}

func (UnimplementedStabilityAiServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedStabilityAiServiceServer) testEmbeddedByValue() {}

// UnsafeStabilityAiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StabilityAiServiceServer will
// result in compilation errors.
type UnsafeStabilityAiServiceServer interface {
	mustEmbedUnimplementedStabilityAiServiceServer()
}

func RegisterStabilityAiServiceServer(s grpc.ServiceRegistrar, srv StabilityAiServiceServer) {
	// If the following call pancis, it indicates UnimplementedStabilityAiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StabilityAiService_ServiceDesc, srv)
}

func _StabilityAiService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StabilityAiServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StabilityAiService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StabilityAiServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StabilityAiService_ServiceDesc is the grpc.ServiceDesc for StabilityAiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StabilityAiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.StabilityAiService",
	HandlerType: (*StabilityAiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyCredential",
			Handler:    _StabilityAiService_VerifyCredential_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration-api.proto",
}

const (
	TogetherAiService_Chat_FullMethodName             = "/integration_api.TogetherAiService/Chat"
	TogetherAiService_VerifyCredential_FullMethodName = "/integration_api.TogetherAiService/VerifyCredential"
)

// TogetherAiServiceClient is the client API for TogetherAiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TogetherAiServiceClient interface {
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type togetherAiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTogetherAiServiceClient(cc grpc.ClientConnInterface) TogetherAiServiceClient {
	return &togetherAiServiceClient{cc}
}

func (c *togetherAiServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatResponse)
	err := c.cc.Invoke(ctx, TogetherAiService_Chat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *togetherAiServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, TogetherAiService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TogetherAiServiceServer is the server API for TogetherAiService service.
// All implementations should embed UnimplementedTogetherAiServiceServer
// for forward compatibility.
type TogetherAiServiceServer interface {
	Chat(context.Context, *ChatRequest) (*ChatResponse, error)
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedTogetherAiServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTogetherAiServiceServer struct{}

func (UnimplementedTogetherAiServiceServer) Chat(context.Context, *ChatRequest) (*ChatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedTogetherAiServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedTogetherAiServiceServer) testEmbeddedByValue() {}

// UnsafeTogetherAiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TogetherAiServiceServer will
// result in compilation errors.
type UnsafeTogetherAiServiceServer interface {
	mustEmbedUnimplementedTogetherAiServiceServer()
}

func RegisterTogetherAiServiceServer(s grpc.ServiceRegistrar, srv TogetherAiServiceServer) {
	// If the following call pancis, it indicates UnimplementedTogetherAiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TogetherAiService_ServiceDesc, srv)
}

func _TogetherAiService_Chat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TogetherAiServiceServer).Chat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TogetherAiService_Chat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TogetherAiServiceServer).Chat(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TogetherAiService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TogetherAiServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TogetherAiService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TogetherAiServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TogetherAiService_ServiceDesc is the grpc.ServiceDesc for TogetherAiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TogetherAiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.TogetherAiService",
	HandlerType: (*TogetherAiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Chat",
			Handler:    _TogetherAiService_Chat_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _TogetherAiService_VerifyCredential_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration-api.proto",
}

const (
	DeepInfraService_VerifyCredential_FullMethodName = "/integration_api.DeepInfraService/VerifyCredential"
)

// DeepInfraServiceClient is the client API for DeepInfraService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeepInfraServiceClient interface {
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type deepInfraServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeepInfraServiceClient(cc grpc.ClientConnInterface) DeepInfraServiceClient {
	return &deepInfraServiceClient{cc}
}

func (c *deepInfraServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, DeepInfraService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeepInfraServiceServer is the server API for DeepInfraService service.
// All implementations should embed UnimplementedDeepInfraServiceServer
// for forward compatibility.
type DeepInfraServiceServer interface {
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedDeepInfraServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeepInfraServiceServer struct{}

func (UnimplementedDeepInfraServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedDeepInfraServiceServer) testEmbeddedByValue() {}

// UnsafeDeepInfraServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeepInfraServiceServer will
// result in compilation errors.
type UnsafeDeepInfraServiceServer interface {
	mustEmbedUnimplementedDeepInfraServiceServer()
}

func RegisterDeepInfraServiceServer(s grpc.ServiceRegistrar, srv DeepInfraServiceServer) {
	// If the following call pancis, it indicates UnimplementedDeepInfraServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeepInfraService_ServiceDesc, srv)
}

func _DeepInfraService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeepInfraServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeepInfraService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeepInfraServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeepInfraService_ServiceDesc is the grpc.ServiceDesc for DeepInfraService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeepInfraService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.DeepInfraService",
	HandlerType: (*DeepInfraServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyCredential",
			Handler:    _DeepInfraService_VerifyCredential_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration-api.proto",
}

const (
	VoyageAiService_Embedding_FullMethodName        = "/integration_api.VoyageAiService/Embedding"
	VoyageAiService_Reranking_FullMethodName        = "/integration_api.VoyageAiService/Reranking"
	VoyageAiService_VerifyCredential_FullMethodName = "/integration_api.VoyageAiService/VerifyCredential"
)

// VoyageAiServiceClient is the client API for VoyageAiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VoyageAiServiceClient interface {
	Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	Reranking(ctx context.Context, in *RerankingRequest, opts ...grpc.CallOption) (*RerankingResponse, error)
	VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error)
}

type voyageAiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVoyageAiServiceClient(cc grpc.ClientConnInterface) VoyageAiServiceClient {
	return &voyageAiServiceClient{cc}
}

func (c *voyageAiServiceClient) Embedding(ctx context.Context, in *EmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, VoyageAiService_Embedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *voyageAiServiceClient) Reranking(ctx context.Context, in *RerankingRequest, opts ...grpc.CallOption) (*RerankingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RerankingResponse)
	err := c.cc.Invoke(ctx, VoyageAiService_Reranking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *voyageAiServiceClient) VerifyCredential(ctx context.Context, in *VerifyCredentialRequest, opts ...grpc.CallOption) (*VerifyCredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyCredentialResponse)
	err := c.cc.Invoke(ctx, VoyageAiService_VerifyCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VoyageAiServiceServer is the server API for VoyageAiService service.
// All implementations should embed UnimplementedVoyageAiServiceServer
// for forward compatibility.
type VoyageAiServiceServer interface {
	Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error)
	Reranking(context.Context, *RerankingRequest) (*RerankingResponse, error)
	VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error)
}

// UnimplementedVoyageAiServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVoyageAiServiceServer struct{}

func (UnimplementedVoyageAiServiceServer) Embedding(context.Context, *EmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Embedding not implemented")
}
func (UnimplementedVoyageAiServiceServer) Reranking(context.Context, *RerankingRequest) (*RerankingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reranking not implemented")
}
func (UnimplementedVoyageAiServiceServer) VerifyCredential(context.Context, *VerifyCredentialRequest) (*VerifyCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyCredential not implemented")
}
func (UnimplementedVoyageAiServiceServer) testEmbeddedByValue() {}

// UnsafeVoyageAiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VoyageAiServiceServer will
// result in compilation errors.
type UnsafeVoyageAiServiceServer interface {
	mustEmbedUnimplementedVoyageAiServiceServer()
}

func RegisterVoyageAiServiceServer(s grpc.ServiceRegistrar, srv VoyageAiServiceServer) {
	// If the following call pancis, it indicates UnimplementedVoyageAiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VoyageAiService_ServiceDesc, srv)
}

func _VoyageAiService_Embedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoyageAiServiceServer).Embedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VoyageAiService_Embedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoyageAiServiceServer).Embedding(ctx, req.(*EmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VoyageAiService_Reranking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoyageAiServiceServer).Reranking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VoyageAiService_Reranking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoyageAiServiceServer).Reranking(ctx, req.(*RerankingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VoyageAiService_VerifyCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoyageAiServiceServer).VerifyCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VoyageAiService_VerifyCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoyageAiServiceServer).VerifyCredential(ctx, req.(*VerifyCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VoyageAiService_ServiceDesc is the grpc.ServiceDesc for VoyageAiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VoyageAiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "integration_api.VoyageAiService",
	HandlerType: (*VoyageAiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Embedding",
			Handler:    _VoyageAiService_Embedding_Handler,
		},
		{
			MethodName: "Reranking",
			Handler:    _VoyageAiService_Reranking_Handler,
		},
		{
			MethodName: "VerifyCredential",
			Handler:    _VoyageAiService_VerifyCredential_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integration-api.proto",
}
